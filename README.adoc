= LeetCode
:toc:
:toc: left

== 1. Two Sum

Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

Example 1:
[source,text]

----
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
----

Example 2:
[source,text]

----
Input: nums = [3,2,4], target = 6
Output: [1,2]
----

Example 3:
[source,text]

----
Input: nums = [3,3], target = 6
Output: [0,1]
----

=== Solution

[source,java]
----
public class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> complements = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            Integer complementIndex = complements.get(nums[i]);
            if (complementIndex != null) {
                return new int[]{complementIndex, i};
            }
            complements.put(target - nums[i], i);
        }
        return nums;
    }
}
----

== 2. Add Two Numbers

You are given two non-empty linked lists representing two non-negative integers.
The digits are stored in reverse order, and each of their nodes contains a single digit.
Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Example 1:
[source,text]

----
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807
----

Example 2:
[source,text]

----
Input: l1 = [0], l2 = [0]
Output: [0]
----

Example 3:
[source,text]

----
Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
----

=== Solution

[source,java]
----
public class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode root = new ListNode(0);
        ListNode node = root;
        int sum = 0;
        while (l1 != null || l2 != null || sum != 0) {
            if (l1 != null) {
                sum = sum + l1.val;
                l1 = l1.next;
            }
            if (l2 != null) {
                sum = sum + l2.val;
                l2 = l2.next;
            }
            node.next = new ListNode(sum % 10);
            sum = sum / 10;
            node = node.next;
        }
        return root.next;
    }
}

class ListNode {
    int val;
    ListNode next;

    ListNode() {
    }

    ListNode(int val) {
        this.val = val;
    }

    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ListNode listNode = (ListNode) o;
        return val == listNode.val && Objects.equals(next, listNode.next);
    }

    @Override
    public int hashCode() {
        return Objects.hash(val, next);
    }
}
----

== 3. Longest Substring Without Repeating Characters

Given a string `s`, find the length of the longest substring without repeating characters.

Example 1:
[source,text]

----
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
----

Example 2:
[source,text]

----
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
----

Example 3:
[source,text]

----
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
----

Notice that the answer must be a substring, "*pwke*" is a subsequence and not a substring.

=== Solution

[source,java]
----
public class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> map = new HashMap<>();
        int maxLength = 0;
        int start = 0;
        for (int end = 0; end < s.length(); end++) {
            if (map.containsKey(s.charAt(end))) {
                start = Math.max(start, map.get(s.charAt(end)) + 1);
            }
            map.put(s.charAt(end), end);
            maxLength = Math.max(maxLength, end - start + 1);
        }
        return maxLength;
    }
}
----

== 4. Median of Two Sorted Arrays

Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays.

The overall run time complexity should be `O(log (m+n))`.

Example 1:
[source,text]

----
Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
----

Example 2:
[source,text]

----
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
----

=== Solution

[source,java]
----
public class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int[] result = IntStream.concat(Arrays.stream(nums1), Arrays.stream(nums2))
                .sorted()
                .toArray();

        return result.length % 2 == 0
                ? (result[(result.length / 2)] + result[result.length / 2 - 1]) / 2.0
                : result[(result.length - 1) / 2];
    }
}
----

== 5. Longest Palindromic Substring

Given a string `s`, return the longest palindromic substring in `s`.

Example 1:
[source,text]

----
Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.
----

Example 2:
[source,text]

----
Input: s = "cbbd"
Output: "bb"
----

=== Solution

[source,java]
----
public class Solution {
    public String longestPalindrome(String s) {
        String longest = s.substring(0, 1);
        for (int i = 0; i < s.length(); i++) {
            String palindrome = getString(s, i, i);
            if (palindrome.length() > longest.length()) {
                longest = palindrome;
            }
            palindrome = getString(s, i, i + 1);
            if (palindrome.length() > longest.length()) {
                longest = palindrome;
            }
        }
        return longest;
    }

    private String getString(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return s.substring(left + 1, right);
    }
}
----

== 7. Reverse Integer

Given a signed 32-bit integer `x`, return `x` with its digits reversed.
If reversing `x` causes the value to go outside the signed 32-bit integer range `[-231, 231 - 1]`, then return 0.

Assume the environment does not allow you to store 64-bit integers (signed or unsigned).

Example 1:
[source,text]

----
Input: x = 123
Output: 321
----

Example 2:
[source,text]

----
Input: x = -123
Output: -321
----

Example 3:
[source,text]

----
Input: x = 120
Output: 21
----

Example 4:
[source,text]

----
Input: x = 1534236469
Output: 0
----

=== Solution

[source,java]
----
public class Solution {
    public int reverse(int x) {
        int iter = x < 0 ? x * -1 : x;
        long result = 0;

        while (iter > 0) {
            result = result * 10 + iter % 10;
            iter = iter / 10;
        }

        if (result > Integer.MAX_VALUE) {
            return 0;
        }

        return x < 0 ? (int) result * -1 : (int) result;
    }
}
----

== 8. String to Integer (atoi)

Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).

The algorithm for myAtoi(string s) is as follows:

. Read in and ignore any leading whitespace.
. Check if the next character (if not already at the end of the string) is `-` or `+`.
Read this character in if it is either.
This determines if the final result is negative or positive respectively.
Assume the result is positive if neither is present.
. Read in next the characters until the next non-digit character or the end of the input is reached.
The rest of the string is ignored.
. Convert these digits into an integer (i.e. `"123" -> 123`, `"0032" -> 32`).
If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).
. If the integer is out of the 32-bit signed integer range `[-2e31, 2e31 - 1]`, then clamp the integer so that it remains in the range.
Specifically, integers less than `-2e31` should be clamped to `-2e31`, and integers greater than `2e31 - 1` should be clamped to `2e31 - 1`.
. Return the integer as the final result.

Note:

* Only the space character `' '` is considered a whitespace character.
* Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.

Example 1:
[source,text]

----
Input: s = "42"
Output: 42
Explanation: The underlined characters are what is read in, the caret is the current reader position.
Step 1: "42" (no characters read because there is no leading whitespace)
Step 2: "42" (no characters read because there is neither a '-' nor '+')
Step 3: "42" ("42" is read in)
The parsed integer is 42.
Since 42 is in the range [-2e31, 2e31 - 1], the final result is 42.
----

Example 2:
[source,text]

----
Input: s = "   -42"
Output: -42
Explanation:
Step 1: "   -42" (leading whitespace is read and ignored)
Step 2: "   -42" ('-' is read, so the result should be negative)
Step 3: "   -42" ("42" is read in)
The parsed integer is -42.
Since -42 is in the range [-23e1, 2e31 - 1], the final result is -42.
----

Example 3:
[source,text]

----
Input: s = "4193 with words"
Output: 4193
Explanation:
Step 1: "4193 with words" (no characters read because there is no leading whitespace)
Step 2: "4193 with words" (no characters read because there is neither a '-' nor '+')
Step 3: "4193 with words" ("4193" is read in; reading stops because the next character is a non-digit)
The parsed integer is 4193.
Since 4193 is in the range [-2e31, 2e31 - 1], the final result is 4193.
----

=== Solution

[source,java]
----
public class Solution {
    public int myAtoi(String s) {
        if (s == null || s.trim().isEmpty()) {
            return 0;
        }
        int i = 0;
        int result = 0;
        int sign = 1;
        s = s.trim();
        if (s.charAt(i) == '-') {
            sign = -1;
            i++;
        } else if (s.charAt(i) == '+') {
            i++;
        }
        while (i < s.length() && Character.isDigit(s.charAt(i))) {
            int d = Integer.parseInt(String.valueOf(s.charAt(i)));
            if (result > (Integer.MAX_VALUE - d) / 10) {
                return sign > 0 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            }
            result = result * 10 + d;
            i++;
        }
        return result * sign;
    }
}
----

== 9. Palindrome Number

Given an integer `x`, return `true` if `x` is a *palindrome*, and `false` otherwise.

Example 1:
[source,text]

----
Input: x = 121
Output: true
Explanation: 121 reads as 121 from left to right and from right to left.
----

Example 2:
[source,text]

----
Input: x = -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
----

Example 3:
[source,text]

----
Input: x = 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
----

=== Solution

[source,java]
----
public class Solution {
    public boolean isPalindrome(int x) {
        if (x == 0) {
            return true;
        }
        if (x < 0 || x % 10 == 0) {
            return false;
        }
        int result = 0;
        while (result < x) {
            result = result * 10 + x % 10;
            x = x / 10;
        }
        return result == x || result / 10 == x;
    }
}
----

== 11. Container With Most Water

You are given an integer array height of length `n`.
There are `n` vertical lines drawn such that the two endpoints of the stem:[i^{th}] line are (`i, 0`) and (`i, height[i]`).

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return the maximum amount of water a container can store.

Notice that you may not slant the container.

Example 1:
[source,text]

----
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
----

image::src/main/resources/images/task11.png[]

Example 2:
[source,text]

----
Input: height = [1,1]
Output: 1
----

=== Solution

[source,java]
----
public class Solution {
    public int maxArea(int[] height) {
        int maxArea = 0;
        int left = 0;
        int right = height.length - 1;
        while (left < right) {
            int leftHeight = height[left];
            int rightHeight = height[right];
            int tempArea = (right - left) * min(leftHeight, rightHeight);
            maxArea = max(maxArea, tempArea);
            if (leftHeight > rightHeight) {
                right--;
            } else if (leftHeight < rightHeight) {
                left++;
            } else {
                left++;
                right--;
            }
        }
        return maxArea;
    }
}
----

== 12. Integer to Roman

Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.

[source,text]
----
Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
----

For example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`.
The number `27` is written as `XXVII`, which is `XX + V + II`.

Roman numerals are usually written largest to smallest from left to right.
However, the numeral for four is not `IIII`.
Instead, the number four is written as `IV`.
Because the one is before the five we subtract it making four.
The same principle applies to the number nine, which is written as `IX`.

There are six instances where subtraction is used:

* `I` can be placed before `V` (5) and `X` (10) to make `4` and `9`.
* `X` can be placed before `L` (50) and `C` (100) to make `40` and `90`.
* `C` can be placed before `D` (500) and `M` (1000) to make `400` and `900`.

Given an integer, convert it to a roman numeral.

Example 1:

[source,text]
----
Input: num = 3
Output: "III"
Explanation: 3 is represented as 3 ones.
----

Example 2:

[source,text]
----
Input: num = 58
Output: "LVIII"
Explanation: L = 50, V = 5, III = 3.
----

Example 3:

[source,text]
----
Input: num = 1994
Output: "MCMXCIV"
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
----

=== Solution

[source,java]
----
public class Solution {
    private final static int[] val = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    private final static String[] rom = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};

    public String intToRoman(int num) {
        StringBuilder result = new StringBuilder();
        for (int i = 0; num > 0; i++) {
            while (num >= val[i]) {
                result.append(rom[i]);
                num -= val[i];
            }
        }
        return result.toString();
    }
}
----

== 13. Roman to Integer

Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.

[source,text]
----
Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
----

For example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`.
The number `27` is written as `XXVII`, which is `XX + V + II`.

Roman numerals are usually written largest to smallest from left to right.
However, the numeral for four is not `IIII`.
Instead, the number four is written as `IV`.
Because the one is before the five we subtract it making four.
The same principle applies to the number nine, which is written as `IX`.

There are six instances where subtraction is used:

* `I` can be placed before `V` (5) and `X` (10) to make `4` and `9`.
* `X` can be placed before `L` (50) and `C` (100) to make `40` and `90`.
* `C` can be placed before `D` (500) and `M` (1000) to make `400` and `900`.

Given a roman numeral, convert it to an integer.

Example 1:

[source,text]
----
Input: s = "III"
Output: 3
Explanation: III = 3.
----

Example 2:

[source,text]
----
Input: s = "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.
----

Example 3:

[source,text]
----
Input: s = "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
----

=== Solution

[source,java]
----
public class Solution {
    private final static Map<Character, Integer> map = new HashMap<>(Map.of(
            'I', 1,
            'V', 5,
            'X', 10,
            'L', 50,
            'C', 100,
            'D', 500,
            'M', 1000
    ));

    public int romanToInt(String s) {
        int result = 0;
        for (int i = 0; i < s.length(); i++) {
            if (i != s.length() - 1) {
                if (map.get(s.charAt(i)) >= map.get(s.charAt(i + 1))) {
                    result += map.get(s.charAt(i));
                } else {
                    result += map.get(s.charAt(i + 1)) - map.get(s.charAt(i));
                    i++;
                }
            } else {
                result += map.get(s.charAt(i));
            }
        }
        return result;
    }
}
----

== 14. Longest Common Prefix

Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string `""`.

Example 1:
[source,text]

----
Input: strs = ["flower","flow","flight"]
Output: "fl"
----

Example 2:
[source,text]

----
Input: strs = ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.
----

=== Solution

[source,java]
----
public class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }
        Arrays.sort(strs);
        String first = strs[0];
        String last = strs[strs.length - 1];
        int counter = 0;
        while (counter < first.length()) {
            if (first.charAt(counter) != last.charAt(counter)) {
                break;
            }
            counter++;
        }
        return counter == 0 ? "" : first.substring(0, counter);
    }
}
----

== 15. 3Sum

Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

Example 1:
[source,text]

----
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation:
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
----

Example 2:
[source,text]

----
Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
----

Example 3:
[source,text]

----
Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.
----

=== Solution

[source,java]
----
public class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        Set<List<Integer>> result = new HashSet<>();
        for (int i = 0; i < nums.length - 2; i++) {
            int j = i + 1;
            int k = nums.length - 1;
            while (j < k) {
                int sum = nums[i] + nums[j] + nums[k];
                if (sum == 0) {
                    List<Integer> temp = new ArrayList<>(List.of(nums[i], nums[j], nums[k]));
                    Collections.sort(temp);
                    result.add(temp);
                    while (j < k && nums[j] == nums[j + 1]) {
                        j++;
                    }
                    while (j < k && nums[k] == nums[k - 1]) {
                        k--;
                    }
                    j++;
                    k--;
                } else if (sum < 0) {
                    j++;
                } else {
                    k--;
                }
            }
        }
        return new ArrayList<>(result);
    }
}
----

== 16. 3Sum Closest

Given an integer array `nums` of length `n` and an integer `target`, find three integers in `nums` such that the sum is closest to `target`.

Return the sum of the three integers.

You may assume that each input would have exactly one solution.

Example 1:
[source,text]

----
Input: nums = [-1,2,1,-4], target = 1
Output: 2
Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
----

Example 2:
[source,text]

----
Input: nums = [0,0,0], target = 1
Output: 0
Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).
----

=== Solution

[source,java]
----
public class Solution {
    public int threeSumClosest(int[] nums, int target) {
        if (nums.length == 3) {
            return nums[0] + nums[1] + nums[2];
        }
        Arrays.sort(nums);
        int result = Math.abs(nums[0] + nums[1] + nums[nums.length - 1]);
        int temp = Math.abs(result - target);
        for (int i = 0; i < nums.length - 2; i++) {
            int j = i + 1;
            int k = nums.length - 1;
            while (j < k) {
                int sum = nums[i] + nums[j] + nums[k];
                if (sum == target) {
                    return sum;
                }
                if (temp > Math.abs(sum - target)) {
                    temp = Math.abs(sum - target);
                    result = sum;
                }
                if (sum > target) {
                    k--;
                } else {
                    j++;
                }
            }
        }
        return result;
    }
}
----
